% Copyright 2019 Clara Eleonore Pavillet

% Author: Clara Eleonore Pavillet
% Description: This is an unofficial Oxford University Beamer Template I made from scratch. Feel free to use it, modify it, share it.
% Version: 1.0

\documentclass{beamer}
\usepackage{pdfpages}
\input{Packages.tex}
\usetheme{oxonian}
\usepackage{wrapfig}
\usepackage{listings}

\title{Използване на OpenMP. Част 2. for, barrier, section, master, single }
\subtitle{\textit{Курс „Паралелно програмиране“}}
\titlegraphic{{\includegraphics[width=5.3cm]{iaps.png}}} 

\author{\newline \newline Стоян Мишев}

\vspace{1cm}

\date{} %\today

\begin{document}
\lstset{language=Python}
{\setbeamertemplate{footline}{} 
\frame{\titlepage}}


\section*{План}\begin{frame}{План}\tableofcontents\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
\frametitle{Теми}
  Loop

  Section

  Master
  
  Single
\end{frame}


\begin{frame}
  \frametitle{Loop}
  Нишките изпълняват итерации с различен номер.

  \centering
  \includegraphics[width=0.5\textwidth]{for}  \pause

  Съкратен запис:

  \includegraphics[width=0.4\textwidth]{for-short}
\end{frame}

\begin{frame}[fragile, plain]
\scriptsize
\lstset{language=C++}
\begin{lstlisting}
  int i = 0;
  omp_set_num_threads(4);

  printf("Total number of threads allocated in the serial section %d \n", omp_get_num_threads() );
  #pragma omp parallel 
  {
    #pragma omp for
    for( i  = 0; i < omp_get_num_threads(); i++) {
      printf("This is run by thread %d, Total threads in the parallel section %d\n", omp_get_thread_num(), omp_get_num_threads());
    }
  }
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Schedule}
  \includegraphics[width=\textwidth]{schedule}  
\end{frame}


\begin{frame}
  \frametitle{Reduction}
  \centering
  \includegraphics[width=0.8\textwidth]{reduction} \pause
  
  \includegraphics[width=0.6\textwidth]{reduction-init}    
\end{frame}


\begin{frame}[fragile, plain]
\scriptsize
\lstset{language=C++}
\begin{lstlisting}
  int tnumber;
  int i = 10, j = 10, k = 10;
  printf("Before parallel region: i=%i, j=%i, k=%i\n", i, j, k);
#pragma omp parallel default(none) private(tnumber) reduction(+:i) reduction(*:j) reduction(^:k)
  {
    tnumber = omp_get_thread_num() + 1;
    i = tnumber;
    j = tnumber;
    k = tnumber;
    printf("Thread %i: i=%i, j=%i, k=%i\n", tnumber, i, j, k);
  }
  printf("After parallel region: i=%d, j=%d, k=%d\n", i, j, k);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Интеграл}
  \begin{equation}
    \int_0^1 \frac{4}{1+x^2} dx = \pi  \nonumber
  \end{equation}
\end{frame}

\begin{frame}[plain]
  \frametitle{Интеграл}
  \centering
  \includegraphics[width=0.6\textwidth]{integral-worksharing}\pause

  \includegraphics[width=0.55\textwidth]{integral-worksharing-time}
\end{frame}


\begin{frame}
  \frametitle{Barrier}
  \centering
  \includegraphics[width=0.7\textwidth]{barrier}
\end{frame}


\begin{frame}
  \frametitle{Section}
  Нишките изпълняват код от различни \texttt{section}
  \centering
  \includegraphics[width=0.5\textwidth]{section}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Section}

\scriptsize
\lstset{language=C++}
\begin{lstlisting}
int a = 6;
int b = 3;
omp_set_num_threads(4);
#pragma omp parallel
{
  #pragma omp sections
  {
    #pragma omp section
    {
      printf("Sum = %d on thread %d \n", a + b, omp_get_thread_num());
    }
    #pragma omp section 
    {
      printf("Difference = %d on thread %d \n", a - b, omp_get_thread_num());
    }
  }
}
\end{lstlisting}

\end{frame}


\begin{frame}
  \frametitle{Master}

  Когато искаме някоя част от кода да се изпълни само от една нишка използваме \texttt{master} или \texttt{single}. При \texttt{signle} нишката, която първа достигне до кода, го изпълнява, докото при \texttt{master} точно нишката с \texttt{id=0} изпълнява кода (, а останалите - не). Няма скрит \texttt{barrier} след \texttt{master}, но има скрит \texttt{barrier} след \texttt{single}.

  \centering
  \includegraphics[width=0.7\textwidth]{master}
\end{frame}


\begin{frame}[fragile,plain]
 \scriptsize
\lstset{language=C++}
\begin{lstlisting}
  int i = 0, N = 8;
  omp_set_num_threads(N);
  int *a, *b, *c;
  #pragma omp parallel
  {
    #pragma omp master
    {
      a = malloc(N * sizeof(int));
      b = malloc(N * sizeof(int));
      c = malloc(N * sizeof(int));
      srand(time(NULL));
    }
    #pragma omp for
    for( i  = 0; i < N; i++) {
      a[i] = rand() % 10;  
      b[i] = rand() % 10;
    }
    #pragma omp for
    for( i  = 0; i < N; i++) {
        c[i] = a[i] * b[i];
    }
    #pragma omp for
    for( i = 0; i < N ; i++) {
      printf("A[%d] * B[%d] = %d \n", i, i, c[i]);
    }
 }
\end{lstlisting}
\end{frame}


\begin{frame}
  \frametitle{Single}
  \centering
  \includegraphics[width=0.7\textwidth]{single}
\end{frame}


\begin{frame}[fragile, plain]
\scriptsize
\lstset{language=C++}
\begin{lstlisting}
  int i = 0, N = 8;
  omp_set_num_threads(N);
  int *a, *b, *c;
  #pragma omp parallel
  {
    #pragma omp single
    {
      a = malloc(N * sizeof(int));
      b = malloc(N * sizeof(int));
      c = malloc(N * sizeof(int));
      srand(time(NULL));
    }
    #pragma omp for
    for( i  = 0; i < N; i++) {
      a[i] = rand() % 10;  
      b[i] = rand() % 10;
    }
    #pragma omp for
    for( i  = 0; i < N; i++) {
        c[i] = a[i] * b[i];
    }
    #pragma omp for
    for( i = 0; i < N ; i++) {
      printf("A[%d] * B[%d] = %d \n", i, i, c[i]);
    }
  }
\end{lstlisting}
\end{frame}


\begin{frame}
  \frametitle{Домашна работа}
\url{https://www.youtube.com/watch?list=PLLbPZJxtMs4ZHSamRRYCtvowRS0qIwC-I}  

От ``Introduction to OpenMP 08 Discussion 3 ''
 
до ``Introduction to OpenMP 11 part 1 Module 6''.
\end{frame}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
